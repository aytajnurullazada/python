question10

import numpy as np 
from numpy.linalg import matrix_power 
import matplotlib.pyplot as plt 
 
 
 
transition = np.array([ 
                       [0.25,0.15,0.2,0.1,0.17,0.13], 
                       [0.13,0.1,0.15,0.05,0.17,0.4],  
                       [0.2,0.25,0.15,0.15,0.2,0.05], 
                       [0.3,0.15,0.1,0.2,0.05,0.2], 
                       [0.23,0.05,0.17,0.25,0.1,0.2],  
                       [0.2,0.15,0.15,0.1,0.15,0.25] 
                       ]) 
 
p1 = np.array([1,0,0,0,0,0]) 
p2 = np.array([0,1,0,0,0,0]) 
p3 = np.array([0,0,1,0,0,0]) 
p4 = np.array([0,0,0,1,0,0]) 
p5 = np.array([0,0,0,0,1,0]) 
p6 = np.array([0,0,0,0,0,1]) 
 
print("probablity of event p3 in 2nd step") 
p3_pred = p3.dot(matrix_power(transition,2)) 
print(p3_pred) 
 
print("probablity of event p3 in 5th step") 
p3_pred = p3.dot(matrix_power(transition,5)) 
print(p3_pred) 
 
print("probablity of event p6 in 2nd step") 
p3_pred = p3.dot(matrix_power(transition,2)) 
print(p3_pred) 
 
print("probablity of event p6 in 5th step") 
p3_pred = p3.dot(matrix_power(transition,5)) 
print(p3_pred) 
 
stationary = [] 
i = 1 
while True: 
  p4_pred_1 = p4.dot(matrix_power(transition, i)) 
  p4_pred_2 = p4.dot(matrix_power(transition, i+1)) 
  stationary = p4_pred_2 
  if(all(p4_pred_1 == p4_pred_2)): 
    break 
  i+=1 
 
 
print("stability: ") 
print(stationary) 
print("stability step: ") 
print(i)

///////////////////////////////////////////////////////
question9

import numpy as np 
 
def flatten(array): 
    shape = np.shape(array) 
    a = array.copy() 
    result = [] 
    while True: 
        try:  
            for i in range(len(a)): 
                result += a[i] 
            a = result.copy() 
            result = [] 
        except(TypeError): 
            break 
         
    return a #, shape 
 
 
def avgpool(arr,shape,st=1): 
    array = arr 
    result = [] 
    node = [] 
    mat=[] 
 
    for i in range(0,len(array)-shape[0]+1,st): 
        node = [] 
        for j in range(0,len(array[0])-shape[1]+1,st): 
            mat = [] 
            for d in array[i:i+shape[0]]: 
                a = d[j:j+shape[0]] 
                mat += a 
            node.append(sum(mat)//len(mat)) 
        result.append(node) 
                
 
                 
    return result 
 
def conv2d(array,filr,st=1): 
    #array = np.array(arr) 
    filterr = np.array(filr) 
    matr = [[0 for i in range(len(filterr))] for i in range(len(filterr[0]))] 
    cell = [] 
    res = [] 
    for i in range(0,len(array)-len(filterr)+1,st): 
        cell = [] 
        for j in range(0,len(array[0])-len(filterr[0])+1,st): 
            for k in range(len(filterr)): 
                for d in range(0,len(filterr[0])): 
                    matr[k][d] = array[i+k][j+d]* filterr[k][d] 
            cell.append(sum([sum(i) for i in matr])) 
        res.append(cell) 
    inp_shape = np.shape(array) 
    filter_shape = np.shape(filterr) 
    out_shape = np.shape(res) 
             
                 
    return res #,inp_shape, filter_shape, out_shape 
 
 
 
array_1 = [[2,1,2,0,0,1], 
           [-1,0,1,-2,0,4], 
           [0,0,0,3,0,0], 
           [0,0,-1,1,1,2], 
           [2,0,0,6,0,0], 
           [1,0,0,0,-1,1], 
           ] 
 
array_2 = [[0,1,2,1,0,1], 
           [-3,2,0,1,2,1], 
           [0,3,1,-3,0,1], 
           [1,0,-2,0,0,0], 
           [0,1,-1,1,0,1], 
           [0,0,4,1,2,1], 
] 
 
 
filter_1 = [[1,1],[1,0]] 
filter_2 = [[3,0],[0,1]] 
 
 
conv_1 = conv2d(array_1,filter_1) 
conv_2 = conv2d(array_2,filter_2) 
 
 
 
sum_matrix = [[0 for i in range(len(conv_1))] for i in range(len(conv_1))] 
 
for i in range(len(conv_1)): 
  for j in range(len(conv_1[0])): 
    sum_matrix[i][j] = conv_1[i][j] + conv_2[i][j] 
 
array_padding = [[0 for i in range(len(conv_1)+2)] for i in range(len(conv_1)+2)] 
 
 
for i in range(1,len(array_padding)-1): 
  for j in range(1,len(array_padding[0])-1): 
    array_padding[i][j] = sum_matrix[i-1][j-1] 
 
pooled_array = avgpool(array_padding,(2,2)) 
 
array_padding = [[0 for i in range(len(pooled_array)+2)] for i in range(len(pooled_array)+2)] 
 
 
for i in range(1,len(array_padding)-1): 
  for j in range(1,len(array_padding[0])-1): 
    array_padding[i][j] = pooled_array[i-1][j-1] 
 
 
flatted_array = flatten(array_padding) 
 
print(flatted_array)
/////////////////////////////////////////
theorical

1) Input size, stride, filter size and padding if there is
2). Pooling is an operation that used to reduce overfitting. Most used one is max, then average and minimum poolings. 
In pooling we take a kernel and stride(sometimes we may need padding to keep original input shape) and walk over the layer.
Lets say kernel size is 2x2 and stride 1, then we will walk from left to right, 
then top to the bottom by 2x2 and pick the greatest number if it is max pooling,
minimum value is it is min pooling and if it is average pooling the we should find the average of the number inside that kernel size.
3)In simple way we can say  Fully connected layer a feed forward neural networks. Final pooling or convolutional
layer of the network is the input of this layer(after it is flattened)
4)In simple words we can say that purpose of dropout Is reduce the overfitting by deactivating
few neurons randomly while we use batch normalization to speed up  the training process. 
It also may reduce generalization errors.
5)“Valid” means there is no need to use padding, while “same” means padding is necessary.
6)Monte Carlo method is a method which finds answer by giving random numbers in large range. 
So in this problem(finding area by MC ) first We will draw figure inside of rectangle 
(It can be different) which is area is known. Then we will give random numbers for each x and y coordinate 
and repeat it numerous times(lets call this x and y dot together), then we will calculate the number of dots
inside of the figure. At last we will get such equation 
area = rectangle_area * (dots inside / total dots)

